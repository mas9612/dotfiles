" vim-plug manages itself
if has('vim_starting')
  set runtimepath+=~/.vim/plugged/vim-plug
  if !isdirectory(expand('~/.vim/plugged/vim-plug'))
    echo 'Installing vim-plug...'
    call system('mkdir -p ~/.vim/plugged/vim-plug')
    call system('git clone https://github.com/junegunn/vim-plug.git ~/.vim/plugged/vim-plug/autoload')
  endif
endif

call plug#begin('~/.vim/plugged')
Plug 'junegunn/vim-plug', {'dir': '~/.vim/plugged/vim-plug/autoload'}
Plug 'Shougo/neosnippet.vim'
Plug 'Shougo/neosnippet-snippets'
Plug 'tpope/vim-fugitive'
Plug 'gregsexton/gitv', {'on': ['Gitv']}
Plug 'Shougo/neocomplete.vim'
Plug 'scrooloose/nerdtree', {'on': 'NERDTreeToggle'}
Plug 'mattn/emmet-vim', {'for': ['htmldjango', 'html', 'css', 'php']}
Plug 'thinca/vim-quickrun', {'on': 'QuickRun'}
Plug 'tpope/vim-surround'
Plug 'othree/html5.vim', {'for': 'html'}
Plug 'hail2u/vim-css3-syntax', {'for': 'css'}
Plug 'pangloss/vim-javascript', {'for': 'js'}
Plug 'jiangmiao/auto-pairs'
Plug 'davidhalter/jedi-vim', {'for': 'python'}
Plug 'hynek/vim-python-pep8-indent', {'for': 'python'}
Plug 'vim-syntastic/syntastic'
Plug 'lervag/vimtex', {'for': 'tex'}
Plug 'Shougo/vimproc.vim', {'do': 'make'}
Plug 'Konfekt/FastFold'
Plug 'godlygeek/tabular'
Plug 'plasticboy/vim-markdown', {'for': 'markdown'}
Plug 'kannokanno/previm', {'for': 'markdown'}
Plug 'itchyny/lightline.vim'
Plug 'tomtom/tcomment_vim'
Plug 'szw/vim-tags'
Plug 'vim-jp/vim-cpp', {'for': ['c', 'cpp']}
Plug 'osyo-manga/vim-marching', {'for': ['c', 'cpp']}
Plug 'kchmck/vim-coffee-script', {'for': 'coffee'}
Plug 'mas9612/mdslide.vim', {'for': 'markdown'}
Plug 'mas9612/md2tex.vim', {'for': 'markdown'}
Plug 'chrisbra/vim-diff-enhanced'
Plug 'osyo-manga/vim-monster', {'for': 'ruby'}
Plug 'fatih/vim-go', {'for': 'go', 'do': ':GoInstallBinaries'}
Plug '/usr/local/opt/fzf'
Plug 'junegunn/fzf.vim'
Plug 'mileszs/ack.vim'
Plug 'majutsushi/tagbar', {'on': ['Tagbar', 'TagbarToggle']}
Plug 'hashivim/vim-terraform', {'for': 'terraform'}
Plug 'vim-scripts/Align'
Plug 'tpope/vim-abolish'
call plug#end()


filetype off
filetype plugin indent off

augroup vimrc
    autocmd!
augroup END

" iterm
if has('unix')
  let s:uname = system('uname -s')
  if s:uname == 'Darwin'
    let g:hybrid_use_iTerm_colors = 1
  endif
endif

" set colorscheme to hybrid
if !filereadable(expand('~/.vim/colors/hybrid.vim'))
  call mkdir('~/.vim/colors', 'p')
  call system('curl -fLo ~/.vim/colors/hybrid.vim https://raw.githubusercontent.com/mas9612/dotfiles/master/vim/colors/hybrid.vim')
endif
colorscheme hybrid
set background=dark

set encoding=utf-8
set fileencodings=utf-8,iso-2022-jp,euc-jp,sjis

set nowritebackup
set nobackup
set noswapfile
set hidden

set ttimeoutlen=100

set path& path+=./**
set ignorecase
set smartcase
set incsearch
set hlsearch

set shiftround
set tabstop=4
set shiftwidth=4
set cindent
set smarttab
set expandtab
set ambiwidth=double
set backspace=indent,eol,start

set list
set listchars=tab:>\ ,trail:-
set number
set showmatch
set matchpairs& matchpairs+=<:>
set grepformat=%f:%l:%m,%f,%l%m,%f\ \ %l%m
set grepprg=grep\ -nH
set ruler
set cursorline
set lazyredraw
set laststatus=2    " show bottom status line always
set wildmenu
set wildmode=list:full
set wildignore+=*.o,*.pyc

set visualbell t_vb=
set noerrorbells

set spell
set spelllang=en,cjk

set tags=./tags;

set diffopt=filler,vertical


iabbrev #b /**************************************************
iabbrev #e **************************************************/


" remap ==================================================
nnoremap : ;
vnoremap : ;
nnoremap ; :
vnoremap ; :

nnoremap j gj
nnoremap k gk
nnoremap gj j
nnoremap gk k

nnoremap Q gq

nnoremap <silent><ESC><ESC> :nohlsearch<CR>

" for ctags
nnoremap <C-]> g<C-]>

" move buffer
nnoremap <silent>[b :bprevious<CR>
nnoremap <silent>]b :bnext<CR>
nnoremap <silent>[B :bfirst<CR>
nnoremap <silent>]B :blast<CR>

" quickfix
nnoremap [q :cprevious<CR>
nnoremap ]q :cnext<CR>
nnoremap [Q :<C-u>cfirst<CR>
nnoremap ]Q :<C-u>clast<CR>

" expand '%%' to current directory in command line mode
cnoremap <expr> %% getcmdtype() == ':' ? expand('%:h').'/' : '%%'

" use up/down key in command line mode
cnoremap <C-p> <Up>
cnoremap <C-n> <Down>


" set filetype
autocmd vimrc BufNewFile,BufRead *.html setlocal filetype=htmldjango
autocmd vimrc BufNewFile,BufRead *.coffee setlocal filetype=coffee
autocmd vimrc BufNewFile,BufRead *.tf setlocal filetype=terraform


" open QuickFix window automatically after use make or grep commands
autocmd vimrc QuickFixCmdPost make,*grep* :cwindow


" remove trailing space
function! s:remove_space()
  if &filetype ==? 'markdown'
    return
  endif

  let cursor = getpos(".")
  %s/\s\+$//ge
  call setpos(".", cursor)
  unlet cursor
endfunction
autocmd vimrc BufWritePre * call <SID>remove_space()

" restore cursor position
autocmd vimrc BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g`\"" | endif


" Template File setting
autocmd vimrc BufNewFile *.ly 0read $HOME/.vim/template/lilypond.txt
autocmd vimrc BufNewFile *.py 0read $HOME/.vim/template/python.txt


" binary editing mode
function! s:edit_binary()
  if &binary
    silent %!xxd -g 1
    set filetype=xxd
  endif
endfunction

function! s:pre_save_binary()
  if &binary
    let b:cursor = getpos(".")
    silent %!xxd -r
  endif
endfunction

function! s:after_save_binary()
  if &binary
    silent %!xxd -g 1
    set nomodified
    call setpos(".", b:cursor)
    unlet b:cursor
  endif
endfunction

augroup Binary
  autocmd!
  autocmd BufReadPre *.bin let &binary=1
  autocmd BufReadPost * call <SID>edit_binary()
  autocmd BufWritePre * call <SID>pre_save_binary()
  autocmd BufWritePost * call <SID>after_save_binary()
augroup END


" plugin ===================

" vim-marching settings
let g:marching_clang_command = "/usr/bin/clang"
let g:marching#clang_command#options = {
\   "cpp" : " -std=c++11 -stdlib=libc++"
\}
let g:marching_include_paths = [
\   "/usr/include",
\   "/usr/local/include",
\]
let g:marching_enable_neocomplete = 1
let g:marching#default_config = {
\ " ignore_pat": '^_\D'
\}


" NeoComplete Settings ===============================
" Use neocomplete.
let g:neocomplete#enable_at_startup = 1
" Use smartcase.
let g:neocomplete#enable_smart_case = 1

let g:neocomplete#use_vimproc = 1

" Set minimum syntax keyword length.
let g:neocomplete#sources#syntax#min_keyword_length = 3
let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'

let g:neocomplete#enable_refresh_always = 1

" Define dictionary.
let g:neocomplete#sources#dictionary#dictionaries = {
    \ 'default' : '',
\}

" Define keyword.
if !exists('g:neocomplete#keyword_patterns')
    let g:neocomplete#keyword_patterns = {}
endif
let g:neocomplete#keyword_patterns['default'] = '\h\w*'

" Plugin key-mappings.
inoremap <expr><C-g>     neocomplete#undo_completion()
inoremap <expr><C-l>     neocomplete#complete_common_string()

" Recommended key-mappings.
" <CR>: close popup and save indent.
inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
function! s:my_cr_function()
  return (pumvisible() ? "\<C-y>" : "" ) . "\<CR>"
  " For no inserting <CR> key.
  "return pumvisible() ? "\<C-y>" : "\<CR>"
endfunction
" <C-h>, <BS>: close popup and delete backword char.
inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"

" Enable omni completion.
augroup neocomplete
    autocmd!
    autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
    autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
    autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
    autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
augroup END

" Enable heavy omni completion.
if !exists('g:neocomplete#sources#omni#input_patterns')
  let g:neocomplete#sources#omni#input_patterns = {}
endif

" For perlomni.vim setting.
" https://github.com/c9s/perlomni.vim
let g:neocomplete#sources#omni#input_patterns.perl = '\h\w*->\h\w*\|\h\w*::'

let g:neocomplete#sources#omni#input_patterns.ruby = '[^. *\t]\.\w*\|\h\w*::'

let g:neocomplete#sources#omni#input_patterns.go = '\h\w*\.\w*'

if !exists('g:neocomplete#force_omni_input_patterns')
    let g:neocomplete#force_omni_input_patterns = {}
endif
let g:neocomplete#force_omni_input_patterns.cpp =
        \ '[^.[:digit:] *\t]\%(\.\|->\)\w*\|\h\w*::\w*'


" neosnippet settings
let g:neosnippet#snippets_directory = '~/.vim/snippets'
imap <C-k>     <Plug>(neosnippet_expand_or_jump)
smap <C-k>     <Plug>(neosnippet_expand_or_jump)
xmap <C-k>     <Plug>(neosnippet_expand_target)
imap <expr><TAB>
\ pumvisible() ? "\<C-n>" :
\ neosnippet#expandable_or_jumpable() ?
\    "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"
smap <expr><TAB> neosnippet#expandable_or_jumpable() ?
\ "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"


" jedi-vim
augroup jedi
    autocmd!
    autocmd FileType python setlocal completeopt-=preview
    autocmd FileType python setlocal omnifunc=jedi#completions
augroup END


" integrate jedi-vim and neocomplete
let g:jedi#completions_enabled = 0
let g:jedi#auto_vim_configuration = 0
let g:neocomplete#force_omni_input_patterns.python = '\h\w*\|[^. \t]\.\w*'


" NERDTree Settings
nnoremap <silent><Leader>e :NERDTreeToggle<CR>
autocmd vimrc bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif


" emmet-vim Settings
let g:user_emmet_settings = {
    \ 'variables': {
    \ 'lang' : 'ja'
    \ }
\}


" syntastic Settings
set statusline+=%#warningmsg#
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%*

let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 0

" syntastic checkers
" let g:syntastic_<filetype>_checkers = ['<checker-name>']
let g:syntastic_cpp_compiler = 'clang++'
let g:syntastic_cpp_compiler_options = ' -std=c++11 -stdlib=libc++'
let g:syntastic_cpp_include_dirs = ['/usr/include', '/usr/local/include']
let g:syntastic_python_checkers = ['flake8']
let g:syntastic_go_checkers = ['golint']


" Tex settings
let g:vimtex_compiler_progname = 'latexmk'
let g:vimtex_compiler_latexmk = {'options': []}
" disable the conceal function
let g:tex_conceal=''
nmap <silent><Leader>c <plug>(vimtex-compile)


" vim-quickrun settings
let g:quickrun_config = {
  \ "_" : {
  \   'runner': 'vimproc',
  \   'runner/vimproc/updatetime': 50,
  \   'outputter' : 'error',
  \   'outputter/error/success' : 'buffer',
  \   'outputter/error/error' : 'quickfix',
  \   'outputter/buffer/split' : ':botright 10sp',
  \   'outputter/buffer/close_on_empty' : 1,
  \},
  \ "cpp" : {
  \   'command': 'c++',
  \   'cmdopt': '--std=c++11 -stdlib=libc++',
  \   'exec': '%c %o %s',
  \   'args': '',
  \}
\}

" Press <C-c> to stop QuickRun
" define custom function to compatible with lazy load
function! s:quickrun_is_running()
  if exists('*quickrun#is_running()')
    return quickrun#is_running()
  else
    return 0
  end
endfunction
nnoremap <expr><silent> <C-c> <SID>quickrun_is_running() ? quickrun#sweep_sessions() : "\<C-c>"


" PreVim Settings
let g:previm_open_cmd = 'open -a "Google Chrome"'


" lightline settings
set noshowmode
let g:lightline = {
    \ 'colorscheme': 'wombat',
    \ 'active': {
    \   'left': [ [ 'mode', 'paste' ],
    \             [ 'fugitive', 'filename' ] ]
    \ },
    \ 'component_function': {
    \   'fugitive': 'LightLineFugitive',
    \   'readonly': 'LightLineReadonly',
    \   'modified': 'LightLineModified',
    \   'filename': 'LightLineFilename'
    \ },
    \ 'separator': { 'left': "\u2b80", 'right': "\u2b82" },
    \ 'subseparator': { 'left': "\u2b81", 'right': "\u2b83" }
\}

function! LightLineModified()
  if &filetype == "help"
    return ""
  elseif &modified
    return "+"
  elseif &modifiable
    return ""
  else
    return ""
  endif
endfunction

function! LightLineReadonly()
  if &filetype == "help"
    return ""
  elseif &readonly
    return "\u2b64"
  else
    return ""
  endif
endfunction

function! LightLineFugitive()
  if exists("*fugitive#head")
    let branch = fugitive#head()
    return branch !=# '' ? "\u2b60 ".branch : ''
  endif
  return ''
endfunction

function! LightLineFilename()
  return ('' != LightLineReadonly() ? LightLineReadonly() . ' ' : '') .
       \ ('' != expand('%:t') ? expand('%:t') : '[No Name]') .
       \ ('' != LightLineModified() ? ' ' . LightLineModified() : '')
endfunction


" vim-tags settings
let g:vim_tags_auto_generate = 1
let g:vim_tags_ctags_binary = "/usr/local/bin/ctags"


" vim-markdown settings
let g:vim_markdown_folding_disabled = 1
let g:vim_markdown_math = 1


" vim-diff-enhanced settings
" started In Diff-Mode set diffexpr
if &diff
  let &diffexpr='EnhancedDiff#Diff("git diff", "--diff-algorithm=histogram")'
endif


" mdslide.vim settings
let g:mdslide_open_browser_cmd = 'open -a Google\ Chrome'


" vim-monster settings
let g:monster#completion#rcodetools#backend = "async_rct_complete"


" vim-go settings
let g:go_snippet_engine = "neosnippet"
let g:go_template_autocreate = 0
let g:go_highlight_operators = 1
let g:go_highlight_functions = 1
let g:go_highlight_methods = 1
let g:go_highlight_types = 1
let g:go_highlight_build_constraints = 1


" fzf.vim settings
let g:fzf_command_prefix = 'Fzf'

let g:fzf_action = {
  \ 'ctrl-t': 'tab split',
  \ 'ctrl-s': 'split',
  \ 'ctrl-v': 'vsplit'
\}

" Default fzf layout
let g:fzf_layout = { 'down': '~30%' }

nnoremap <C-p> :FzfFiles<CR>
cabbrev ls FzfBuffers


" ack.vim settings
if executable('ag')
  let g:ackprg = 'ag --vimgrep'
endif


" tagbar settings
nnoremap <silent><Leader>t :TagbarToggle<CR>


" vim-terraform settings
let g:terraform_fmt_on_save = 1


filetype plugin indent on
runtime macros/matchit.vim
runtime ftplugin/man.vim
syntax on
